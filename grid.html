<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Grid + Pan/Zoom + Dice Widget</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #fff;
    }
    .toolbar {
      height: 44px;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-bottom: 1px solid #e5e5e5;
    }
    .badge {
      border: 1px solid #ccc;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 12px;
    }
    .wrap {
      position: relative;
      height: calc(100% - 44px);
      overflow: hidden;
      background: #fff;
      cursor: default;
    }

    /* BOARD ‚Äî fixed-size, exact multiple of cell size */
    .board {
      position: absolute;
      top: 0;
      left: 0;
      width: 7200px;         /* 150 cols √ó 48px */
      height: 4800px;        /* 100 rows √ó 48px */
      transform-origin: 0 0;

      /* Grid lines (thicker so they survive zoom-out) */
      background-image:
        linear-gradient(#000 2px, transparent 2px),
        linear-gradient(90deg, #000 2px, transparent 2px);
      background-size: 48px 48px, 48px 48px;  /* <-- If you change CELL, change this */
      background-position: 0 0;
    }

    /* TOKENS  */
    .token {
      position: absolute;
      border-radius: 50%;
      background: rgba(0, 128, 255, 0.75);
      border: 2px solid #004080;
      box-sizing: border-box;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      user-select: none;
      transition: transform 0.1s;
    }

    .token.dragging {
      opacity: 0.8;
      cursor: grabbing;
      transform: scale(1.1);
    }

    .token .resize-handle {
      position: absolute;
      bottom: -5px;
      right: -5px;
      width: 12px;
      height: 12px;
      background: #004080;
      border: 2px solid #fff;
      border-radius: 2px;
      cursor: se-resize;
    }

    .token input.rename {
      position: absolute;
      bottom: -26px;
      left: 50%;
      transform: translateX(-50%);
      width: 80px;
      border: 1px solid #888;
      border-radius: 4px;
      font-size: 12px;
      padding: 2px 4px;
    }

  .token.selected {
      outline: 3px dashed #ff3b30;
      outline-offset: 2px;
    }


    /* WIDGETS */
    .widget {
      position: absolute;
      width: 260px;
      background: #fafafa;
      border: 1px solid #aaa;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      user-select: none;
    }
    .widget .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 10px;
      background: #f0f0f0;
      border-bottom: 1px solid #ddd;
      border-radius: 10px 10px 0 0;
      cursor: move; /* drag handle */
      font-weight: 600;
    }
    .widget .close {
      border: none;
      background: transparent;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      padding: 0 4px;
    }
    .widget .body {
      padding: 10px;
    }
    .row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }
    .row input[type="text"] {
      flex: 1;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 14px;
      user-select: auto;
    }
    .row button {
      padding: 6px 10px;
      border: 1px solid #999;
      background: #fff;
      border-radius: 6px;
      cursor: pointer;
    }
    .results {
      border-top: 1px dashed #ddd;
      padding-top: 6px;
      max-height: 160px;
      overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
    }
    .muted { color: #666; }

     /* ADDED FOR TOKEN WIDGET */
    .token .token-body {
      text-align: center;
    }
    .token .counter {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 6px;
      margin-bottom: 8px;
    }
    .token .counter button {
      width: 28px;
      height: 28px;
      font-size: 18px;
      border: 1px solid #aaa;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
    }
    .token .counter .count {
      font-size: 18px;
      width: 32px;
      text-align: center;
    }
    /* end point */
  </style>
</head>
<body>
  <div class="toolbar">
    <span class="badge">Pan: Middle-mouse</span>
    <span class="badge">Zoom: Wheel</span>
    <button id="resetBtn">Reset view</button>
    <button id="addDiceBtn">+ Add Dice Roller</button>
    <button id="addTokenBtn">+ Add Token</button>
  </div>

  <div class="wrap" id="wrap">
    <div class="board" id="board"></div>
  </div>

  <script>
    // ========= Base pan & zoom =========
    const wrap  = document.getElementById('wrap');
    const board = document.getElementById('board');
    const resetBtn = document.getElementById('resetBtn');

    let scale = 1;
    let panX  = 0;
    let panY  = 0;
    const CELL = 48; // <--- set this to your grid cell size (match background-size)

    function applyTransform() {
      board.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    }
    function resetView() { scale = 1; panX = 0; panY = 0; applyTransform(); }
    resetBtn.addEventListener('click', resetView);
    applyTransform();

    // Zoom around cursor
    wrap.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = board.getBoundingClientRect();
      const cx = (e.clientX - rect.left) / scale;
      const cy = (e.clientY - rect.top)  / scale;
      const direction = Math.sign(e.deltaY);
      const factor = direction > 0 ? 0.9 : 1.1;
      const newScale = Math.min(3, Math.max(0.2, scale * factor));
      if (newScale === scale) return;
      panX = e.clientX - cx * newScale;
      panY = e.clientY - cy * newScale;
      scale = newScale;
      applyTransform();
    }, { passive: false });

    // Middle-mouse panning
    let panning = false;
    let startX = 0, startY = 0;
    let basePanX = 0, basePanY = 0;

    wrap.addEventListener('mousedown', (e) => {
      if (e.button !== 1) return; // middle only
      panning = true;
      startX = e.clientX; startY = e.clientY;
      basePanX = panX; basePanY = panY;
      e.preventDefault();
    });
    window.addEventListener('mousemove', (e) => {
      if (!panning) return;
      panX = basePanX + (e.clientX - startX);
      panY = basePanY + (e.clientY - startY);
      applyTransform();
    });
    window.addEventListener('mouseup', () => { panning = false; });

    // Convert screen coords -> board coords (pre-transform)
    function toBoardCoords(clientX, clientY) {
      const rect = board.getBoundingClientRect();
      return {
        x: (clientX - rect.left) / scale,
        y: (clientY - rect.top)  / scale
      };
    }
    function snap(v) { return Math.round(v / CELL) * CELL; }

    // ========= Dice widget =========
    const addDiceBtn = document.getElementById('addDiceBtn');
    addDiceBtn.addEventListener('click', () => addDiceWidget(0, 0));

    function addDiceWidget(x, y) {
      const el = document.createElement('div');
      el.className = 'widget';
      el.style.left = snap(x) + 'px';
      el.style.top  = snap(y) + 'px';
      el.innerHTML = `
        <div class="header">
          <div>üé≤ Dice Roller</div>
          <button class="close" title="Remove">&times;</button>
        </div>
        <div class="body">
          <div class="row">
            <input type="text" class="expr" placeholder="Ex: d20, 3d6+2, 2d8-1" />
            <button class="roll">Roll</button>
          </div>
          <div class="results"><div class="muted">No rolls yet.</div></div>
        </div>
      `;

      // Close (remove)
      el.querySelector('.close').addEventListener('click', () => el.remove());

      // Dragging (header acts as handle)
      const header = el.querySelector('.header');
      let dragging = false;
      let start = {x:0, y:0};
      let origin = {x:0, y:0};

      header.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // left only
        dragging = true;
        const bpt = toBoardCoords(e.clientX, e.clientY);
        start = bpt;
        origin = {
          x: parseFloat(el.style.left) || 0,
          y: parseFloat(el.style.top)  || 0
        };
        e.preventDefault();
      });
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const bpt = toBoardCoords(e.clientX, e.clientY);
        const dx = bpt.x - start.x;
        const dy = bpt.y - start.y;
        el.style.left = (origin.x + dx) + 'px';
        el.style.top  = (origin.y + dy) + 'px';
      });
      window.addEventListener('mouseup', () => {
        if (!dragging) return;
        dragging = false;
        // snap to grid on drop
        el.style.left = snap(parseFloat(el.style.left)) + 'px';
        el.style.top  = snap(parseFloat(el.style.top))  + 'px';
      });

      // Dice logic
      const input  = el.querySelector('.expr');
      const rollBt = el.querySelector('.roll');
      const out    = el.querySelector('.results');

      rollBt.addEventListener('click', () => {
        const text = input.value.trim() || 'd20';
        const spec = parseDice(text);
        if (!spec) {
          out.insertAdjacentHTML('afterbegin', `<div>‚ö†Ô∏è Invalid: <code>${escapeHtml(text)}</code></div>`);
          return;
        }
        const rolls = roll(spec.n, spec.sides);
        const total = rolls.reduce((a,b)=>a+b, 0) + spec.mod;
        const ts = new Date().toLocaleTimeString();
        const detail = `${spec.n}d${spec.sides}${fmtMod(spec.mod)}`;
        const list = rolls.join(', ');
        const line = `<div>[${ts}] <b>${detail}</b> ‚Üí <b>${total}</b> <span class="muted">(rolls: ${list}${spec.mod ? `; mod ${fmtMod(spec.mod)}`:''})</span></div>`;
        // first message removes the "No rolls yet."
        if (out.firstElementChild && out.firstElementChild.classList.contains('muted')) out.firstElementChild.remove();
        out.insertAdjacentHTML('afterbegin', line);
      });

      // Append widget to board
      board.appendChild(el);
      // Focus input for quick typing
      el.querySelector('.expr').focus();
    }

    function parseDice(s) {
      // Supports: d20, 2d6, 3d6+2, 4d8-1 (NdS [+/- K])
      const m = /^\s*(\d*)\s*[dD]\s*(\d+)\s*([+-]\s*\d+)?\s*$/.exec(s);
      if (!m) return null;
      const n = m[1] ? parseInt(m[1],10) : 1;
      const sides = parseInt(m[2],10);
      const mod = m[3] ? parseInt(m[3].replace(/\s+/g,''),10) : 0;
      if (!(n > 0 && sides > 0)) return null;
      return { n, sides, mod };
    }
    function roll(n, sides) {
      const out = [];
      for (let i=0; i<n; i++) out.push(1 + Math.floor(Math.random() * sides));
      return out;
    }
    function fmtMod(m) { return m === 0 ? '' : (m > 0 ? `+${m}` : `${m}`); }
    function escapeHtml(t){ return t.replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }


    // ========= VISUAL TOKEN SYSTEM =========
    const addTokenBtn = document.getElementById('addTokenBtn');
    addTokenBtn.addEventListener('click', () => addVisualToken(0, 0));
    function addVisualToken(x, y) {
      const token = document.createElement('div');
      token.className = 'token';
      token.style.left = snap(x) + 'px';
      token.style.top  = snap(y) + 'px';
      token.style.width = '48px';
      token.style.height = '48px';
      token.textContent = 'Token';

      const resizeHandle = document.createElement('div');
      resizeHandle.className = 'resize-handle';
      token.appendChild(resizeHandle);

      let size = 48;
      let dragging = false;
      let resizing = false;
      let start = {x: 0, y: 0};
      let origin = {x: 0, y: 0};

      // === Dragging ===
      token.addEventListener('mousedown', (e) => {
        if (e.button !== 0 || e.target === resizeHandle) return;
        dragging = true;
        token.classList.add('dragging');
        const bpt = toBoardCoords(e.clientX, e.clientY);
        start = bpt;
        origin = {
          x: parseFloat(token.style.left) || 0,
          y: parseFloat(token.style.top) || 0
        };
        e.preventDefault();
      });

      window.addEventListener('mousemove', (e) => {
        if (dragging) {
          const bpt = toBoardCoords(e.clientX, e.clientY);
          const dx = bpt.x - start.x;
          const dy = bpt.y - start.y;
          token.style.left = (origin.x + dx) + 'px';
          token.style.top  = (origin.y + dy) + 'px';
        }

        if (resizing) {
          const currentBoard = toBoardCoords(e.clientX, e.clientY);
          const dx = currentBoard.x - start.x;
          const dy = currentBoard.y - start.y;
          const delta = Math.max(dx, dy);
          const newSize = Math.max(24, size + delta);
          token.style.width = newSize + 'px';
          token.style.height = newSize + 'px';
          token.style.fontSize = (newSize / 3) + 'px';
        }
      });

      window.addEventListener('mouseup', () => {
        if (dragging) {
          dragging = false;
          token.classList.remove('dragging');
          token.style.left = snap(parseFloat(token.style.left)) + 'px';
          token.style.top  = snap(parseFloat(token.style.top))  + 'px';
        }
        resizing = false;
      });

      // === Resizing (bottom-right handle) ===
      resizeHandle.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        resizing = true;
        const bpt = toBoardCoords(e.clientX, e.clientY);
        start = bpt;
        size = parseFloat(token.style.width);
        e.preventDefault();
      });

      // === Rename (double-click) ===
      token.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        const input = document.createElement('input');
        input.type = 'text';
        input.value = token.textContent;
        input.className = 'rename';
        token.appendChild(input);
        input.focus();

        input.addEventListener('blur', () => {
          token.textContent = input.value || 'Token';
          token.appendChild(resizeHandle);
        });

        input.addEventListener('keydown', (ev) => {
          if (ev.key === 'Enter') input.blur();
        });
      });

      // === Select token ===
      token.addEventListener('click', (e) => {
        e.stopPropagation();
        document.querySelectorAll('.token.selected').forEach(t => t.classList.remove('selected'));
        token.classList.add('selected');
      });

      board.appendChild(token);
    }
      // Global delete: remove selected token (ignore when typing)
      window.addEventListener('keydown', (e) => {
        const active = document.activeElement;
        const isTyping = active && (
          active.tagName === 'INPUT' ||
          active.tagName === 'TEXTAREA' ||
          active.isContentEditable
        );

        if (isTyping) return; // do not delete while editing text

        if (e.key === 'Backspace' || e.key === 'Delete') {
          const selected = document.querySelector('.token.selected');
          if (selected) selected.remove();
        }
      });

      // Deselect token when clicking empty board (but not during edit/resize)
      board.addEventListener('click', (e) => {
        // ignore clicks inside tokens
        if (e.target.classList.contains('token') || e.target.closest('.token')) return;

        // ignore clicks when renaming (an input is active)
        const active = document.activeElement;
        const isEditing = active && active.tagName === 'INPUT';
        if (isEditing) return;

        // ignore clicks if resizing
        if (document.querySelector('.resize-handle:active')) return;

        // otherwise clear selection
        document.querySelectorAll('.token.selected').forEach(t => t.classList.remove('selected'));
      });

  </script>
</body>
</html>
